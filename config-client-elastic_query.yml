elastic-query-service:
  version: v1
  # Criado no console do keycloak como clients, utilizado na classe AudienceValidator
  # através da classe ElasticQueryServiceConfigData
  custom-audience: elastic-query-service

server:
  port: 8183
  servlet:
    # Propriedade necessária para definir um caminho de contexto para um aplicativo da web
    context-path: /elastic-query-service

spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          # As uris abaixo devem ser visualizadas no Postman rodando "OpenID Endpoint Configuration" ou
          # pelo console admin do keycloak para o realm criado em "Realm settings", "Endpoints": "OpenID Endpoint Configuration"
          issuer-uri: http://localhost:9091/auth/realms/microservices-realm
          jwk-set-uri: http://localhost:9091/auth/realms/microservices-realm/protocol/openid-connect/certs
  jpa:
    # Colocado false, pois é true por padrão, o que causa o contexto de persistência para ficar aberto,
    # o que não é bom para o desempenho.
    open-in-view: false
    show-sql: true
    database-platform: org.hibernate.dialect.PostgreSQL9Dialect
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQL9Dialect
  datasource:
    # Abaixo é um exemplo caso o banco de dados não esteja no docker
    # Utilizando o Schema: public,
    # binaryTransfer: true para melhor desempenho e
    # reWriteBatchedInserts: true para inserções em lote no banco de dados, que executará todas as instruções
    #   de inserção enviadas ao PostgreSql em lotes, desde que estejam na mesma transação
    url: jdbc:postgresql://localhost:5440/postgres?currentSchema=public&binaryTransfer=true&reWriteBatchedInserts=true
    # postgres -> nome do serviço do banco de dados postgres utilizado no keycloak no docker
#    url: jdbc:postgresql://postgres/keycloak?currentSchema=public&binaryTransfer=true&reWriteBatchedInserts=true
#    url: jdbc:postgresql://localhost:5442/keycloak?currentSchema=public&binaryTransfer=true&reWriteBatchedInserts=true
    username: postgres
    password: '{cipher}4b5e4d55c2ccc0509837c7ee268af738d6d4f08a4268ecaadcb9b7e7244f19f8'
#    password: '{cipher}4d0c8fffa9106d0c7075ed0f8e04f1abb2fb092e899ddb88f5fe06e7074b2dd4'
    driver-class-name: org.postgresql.Driver
    # https://docs.spring.io/spring-boot/docs/1.2.0.M1/reference/html/howto-database-initialization.html
    # set it to the vendor name of the database (hsqldb, h2, oracle, mysql, postgresql etc.)
    platform: postgres
    schema: classpath:init-schema.sql  # classpath -> /src/main/resources
    data: classpath:init-data.sql
    initialization-mode: always  # Colocado para executar os arquivos .sql toda vez que o aplicativo inicializar (apenas para demonstração)

# Estas propriedades serão lidas pela classe ElasticQueryConfigData do módulo: app-config-data
elastic-query-config:
  text-field: text  # propriedade da classe TwitterIndexModel do módulo: elastic-model

# Estas propriedades serão lidas pela classe ElasticConfigData no módulo: app-config-data
elastic-config:
  index-name: twitter-index
  connection-url: http://localhost:9200
  connect-timeout-ms: 5000
  socket-timeout-ms: 30000

# Estas propriedades serão lidas pela classe WebSecurityConfig no módulo: elastic-query-service
user-config:
  username: test
#  password: '{cipher}baeb90d57edb9a050b97b98a7d8cabe80ee884e6fff16c22956172459a43e54d'
  password: '{cipher}78620071212faa6fbc1331721ce51e9afd65baf413eaf4cb8c3560831e1f1118'
  roles: USER

springdoc:
  api-docs:
    path: /api-docs
  swagger-ui:
    path: /swagger-ui.html

# Estas propriedades serão lidas pela classe WebSecurityConfig no módulo: elastic-query-service
security:
  paths-to-ignore: /api-docs